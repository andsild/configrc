# test -f /local/skel/all.bashrc && . /local/skel/all.bashrc
# If not running interactively, don't read preferences.
[ -z "$PS1" ] && return


# Variables ##
# PS1='\u@\h: ~${PWD##*/} > '
GREEN=$'\e[01;32m'
YELLOW=$'\e[00;33m'
WHITE=$'\e[00;00m'
RED=$'\e[01;31m'
PS1=$(printf "\[${YELLOW}\]%s \[${WHITE}\]%s\n:\[${WHITE}\]\n" \
         "$(date +%k:%M)" \
         "\u@\h: ./${PWD##*/}")
# PROMPT_COMMAND=__prompt_command  # Func to gen PS1 after CMDs
# function __prompt_command() {
#     local EXIT="$?"
#         "$(date +%k:%M)" \
#         "\u@\h: ./${PWD##*/}")"
#     if [ $EXIT = 0 ]; then
#         PS1+="${GREEN}:)"      # Add red if exit code non 0
#     else
#         PS1+="${RED}:("
#     fi
#     PS1+="${WHITE}\n$ "
# }


EDITOR="nvim"
HISTIGNORE="ls:l:clear"
export GOPATH="${HOME}/.go"
PATH="${PATH}:${HOME}/dotfiles/Bash:$GOROOT/bin:$GOPATH/bin:${HOME}/.cabal/bin"

export HISTCONTROL="ignoreboth:erasedups"

# Disable Software Flow Control (xon)
# (in practice: give me back Ctrl+s and Ctrl+q)
stty -ixon

# XMonad needs this to run java nicely
export _JAVA_AWT_WM_NONREPARENTING=1

# My jedi-vim needs this(ugh!)
export IPYTHONDIR="${HOME}/.ipython"

# It's a lot more annoying to not have an old command in history than having a large file
export HISTSIZE=100000
export HISTFILE_SIZE=1000000

# If the command-line has an empty entry, don't try to autocomplete with tab
shopt -s no_empty_cmd_completion

# need the if statement for e.g. mac
if [ "${BASH_VERSINFO[0]}" -ge 4 ] 
then
    shopt -s autocd dirspell 
    shopt -s histappend
fi

# Enable directory autocorrection
shopt -s cdspell 

BASH_ALIASES="${HOME}/.bash_aliases"
source "${BASH_ALIASES}"
for file in ${HOME}/dotfiles/Bash/Sourced/* ; do source ${file}; done

complete -cf sudo

[ -f ~/.fzf.bash ] && source ~/.fzf.bash
export SCIPY_PIL_IMAGE_VIEWER=xdg-open
export XDG_CONFIG_HOME="${HOME}/.config/local"
export FZF_DEFAULT_OPTS='--extended -i --exact'
export FZF_COMPLETION_OPTS='--extended --exact'

if [ -f "$(brew --prefix)/opt/bash-git-prompt/share/gitprompt.sh" ]; then
    source "$(brew --prefix)/opt/bash-git-prompt/share/gitprompt.sh"
fi
command -v brew > /dev/null
if [[ "$?" = 0 ]]; then
    # brew install bash-completion bash-git-prompt
    source "$(brew --prefix)/opt/bash-git-prompt/share/gitprompt.sh"
    source "$(brew --prefix)/etc/bash_completion"
else
    source ~/.bash-git-prompt/gitprompt.sh
    # Get proper auto-completion
    if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
            . /etc/bash_completion
    fi

fi
# Set config variables first
   GIT_PROMPT_ONLY_IN_REPO=1

function _nman {
    local l=$#
    local -a page
    local page=(${@:1:$l-1})
    if [[ -z "$page" ]]; then
        echo "What manual page do you want?"
        return
    fi
    local tmp=$IFS
    IFS=$'\n' out=($(command man -w ${page[@]} 2>&1))
    local code=$?
    IFS=$tmp
    if [[ ${#out[@]} > 1 ]]; then
        echo "Too many manpages"
        return
    elif [[ $code != 0 ]]; then
        echo "No manual entry for ${page[*]}"
        return
    fi
    if [[ -z $NVIM_LISTEN_ADDRESS ]]; then
        command nvim -c "${@: -1} ${page[*]}"
    else
        nvr -c "${@: -1} ${page[*]}"
    fi
}
function nman() {
    _nman "$@" 'Nman'
}
function nman!
{
    _nman "$@" 'Nman!'
}
alias man='nman'
complete -o default -o nospace -F _man nman
complete -o default -o nospace -F _man nman!
