# test -f /local/skel/all.bashrc && . /local/skel/all.bashrc
# If not running interactively, don't read preferences.
[ -z "$PS1" ] && return


# Variables ##
# PS1='\u@\h: ~${PWD##*/} > '
GREEN=$'\e[01;32m'
YELLOW=$'\e[00;33m'
WHITE=$'\e[00;00m'
RED=$'\e[01;31m'
PROMPT_COMMAND=__prompt_command  # Func to gen PS1 after CMDs
function __prompt_command() {
    local EXIT="$?"             # This needs to be first
    PS1="`export EXITSTATUS=$?`$(printf "\[${YELLOW}\]%s \[${WHITE}\]%s %s \[${WHITE}\]" \
        "$(date +%k:%M)" \
        "\u@\h: ./${PWD##*/}")"
    if [ $EXIT = 0 ]; then
        PS1+="${GREEN}:)"      # Add red if exit code non 0
    else
        PS1+="${RED}:("
    fi
    PS1+="${WHITE}\n$ "
}


EDITOR="nvim"
HISTIGNORE="ls:l:clear"
PATH="${PATH}:${HOME}/dotfiles/Bash:$GOROOT/bin:$GOPATH/bin"

export HISTCONTROL="ignoreboth:erasedups"

# Disable Software Flow Control (xon)
# (in practice: give me back Ctrl+s and Ctrl+q)
stty -ixon

# XMonad needs this to run java nicely
export _JAVA_AWT_WM_NONREPARENTING=1

# My jedi-vim needs this(ugh!)
export IPYTHONDIR="${HOME}/.ipython"


# It's a lot more annoying to not have an old command in history than having a large file
export HISTSIZE=100000
export HISTFILE_SIZE=1000000


# Reload history after each command (needed to share history across shells live)
# export PROMPT_COMMAND="history -a; history -c; history -r; $PROMPT_COMMAND"

# Append dirname to window title if WMII_IS_RUNNING
# WMII_IS_RUNNING=`ps a | grep wmii | awk '/[^"grep"] wmii$/'`
# if [ -n "$WMII_IS_RUNNING" ]
# then
#   PROMPT_COMMAND="${PROMPT_COMMAND} ; dirs | wmiir write /client/sel/label"
# fi

# If the command-line has an empty entry, don't try to autocomplete with tab
shopt -s no_empty_cmd_completion
# Enable auto cding, so you don't have to use "cd /the/dir" just "/the/dir"
shopt -s autocd
# Enable directory autocorrection
shopt -s cdspell dirspell
# Append history across shells
shopt -s histappend

BASH_INCLUDES_DEST="${HOME}/.bash_includes"
# Check for file and include it
[ -e "${BASH_INCLUDES_DEST}" ] && source "${BASH_INCLUDES_DEST}"

# Get proper auto-completion
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
        . /etc/bash_completion
fi

complete -cf sudo

[ -f ~/.fzf.bash ] && source ~/.fzf.bash
export SCIPY_PIL_IMAGE_VIEWER=xdg-open
export XDG_CONFIG_HOME="/home/andesil/.config"
export FZF_DEFAULT_OPTS='--extended -i'
source /usr/share/bash-completion/bash_completion

source ~/.bash-git-prompt/gitprompt.sh
# Set config variables first
   GIT_PROMPT_ONLY_IN_REPO=1

   # GIT_PROMPT_FETCH_REMOTE_STATUS=0   # uncomment to avoid fetching remote status

   # GIT_PROMPT_SHOW_UPSTREAM=1 # uncomment to show upstream tracking branch
   # GIT_PROMPT_SHOW_UNTRACKED_FILES=all # can be no, normal or all; determines counting of untracked files

   # GIT_PROMPT_STATUS_COMMAND=gitstatus_pre-1.7.10.sh # uncomment to support Git older than 1.7.10

   # GIT_PROMPT_START=...    # uncomment for custom prompt start sequence
   # GIT_PROMPT_END=...      # uncomment for custom prompt end sequence

   # as last entry source the gitprompt script
   # GIT_PROMPT_THEME=Custom # use custom .git-prompt-colors.sh
   # GIT_PROMPT_THEME=Solarized # use theme optimized for solarized color scheme
